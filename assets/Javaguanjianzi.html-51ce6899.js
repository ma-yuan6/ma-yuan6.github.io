import{_ as n,o as a,c as s,e as t}from"./app-9e62998e.js";const i={},e=t(`<h2 id="this" tabindex="-1"><a class="header-anchor" href="#this" aria-hidden="true">#</a> this</h2><ul><li>this 代表当前类对象的引用（地址）。</li><li>this 可以解决局部变量和成员变量的重名问题。</li><li>哪一个对象调用方法，方法中的 this，代表的就是哪一个对象。</li><li>this 可以调用本类成员 (变量，方法)。</li></ul><p>this. 的省略规则：</p><ul><li>本类成员方法：没有前提条件，this. 可以直接省略。</li><li>本类成员变量：方法中没有出现重名的变量，this. 才可以省略。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">shout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;我叫&quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="super" tabindex="-1"><a class="header-anchor" href="#super" aria-hidden="true">#</a> super</h2><ul><li><p><strong>this</strong>：代表本类对象的引用。</p></li><li><p><strong>super</strong>：代表父类存储空间的标识。</p></li></ul><table><thead><tr><th><strong>关键字</strong></th><th><strong>访问成员变量</strong></th><th><strong>访问成员方法</strong></th><th><strong>访问构造方法</strong></th></tr></thead><tbody><tr><td>this</td><td>this.本类成员变量</td><td>this.本类成员方法()</td><td>this()；this(…) 本类构造方法</td></tr><tr><td>super</td><td>super.父类成员变量</td><td>super.父类成员方法()</td><td>super()；super(…) 父类构造方法</td></tr></tbody></table><h2 id="权限修饰符" tabindex="-1"><a class="header-anchor" href="#权限修饰符" aria-hidden="true">#</a> 权限修饰符</h2><p><img src="https://s2.loli.net/2024/03/16/41ckei5R7ZauYgI.png" alt="image-20231008210028273"></p><h2 id="static" tabindex="-1"><a class="header-anchor" href="#static" aria-hidden="true">#</a> static</h2><p>static 是静态的意思，可以修饰成员变量，也可以修饰成员方法。</p><ul><li><p>被其修饰的成员被该类的所有对象所共享。</p></li><li><p>多了一种调用方式，可以通过类名调用。</p></li><li><p>随着类的加载而加载，优先于对象存在。</p></li></ul><p>是否被 static 修饰：</p><ul><li><p>成员变量：是否需要被共享。</p></li><li><p>成员方法：工具类（需要 <em><strong>私有构造方法</strong></em>）。</p></li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li><p>static 方法中，只能访问静态成员 (直接访问)（因为静态成员随着类加载而加载，非静态的随着对象的加载而加载）。</p></li><li><p>static 中不允许使用 this 关键字。</p></li></ul></div><h2 id="extends" tabindex="-1"><a class="header-anchor" href="#extends" aria-hidden="true">#</a> extends</h2><p>用于继承，使用格式：<code>class 子类 extends 父类 { }</code></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span><span class="token punctuation">{</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="final" tabindex="-1"><a class="header-anchor" href="#final" aria-hidden="true">#</a> final</h2><p>final 是最终的意思，可以修饰方法、类、变量</p><ul><li><p>修饰方法：表明该方法是最终方法，<strong>不能被重写。</strong></p></li><li><p>修饰类：表明该类是最终类，<strong>不能被继承</strong>。</p></li><li><p>修饰变量：表明该变量是常量，<strong>不能再次被赋值。</strong></p></li></ul><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li><p>变量是基本类型：final 修饰指的是基本类型的<strong>数据值</strong>不能发生改变。</p></li><li><p>变量是引用类型：final 修饰指的是引用类型的<strong>地址值</strong>不能发生改变，但是地址里面的内容是可以发生改变的。</p></li><li><p>成员变量如果被 final 修饰，需要在构造方法结束之前完成赋值。</p></li></ul></div><h2 id="abstract" tabindex="-1"><a class="header-anchor" href="#abstract" aria-hidden="true">#</a> abstract</h2><p>用于修饰抽象方法、抽象类。</p><p>抽象方法的定义格式：<code>public abstract 返回值类型 方法名(参数列表);</code></p><p>抽象类的定义格式：<code>public abstract class 类名{ }</code></p><div class="hint-container warning"><p class="hint-container-title">注意</p><ul><li><p>抽象类不能实例化。</p></li><li><p>抽象类存在构造方法。</p></li><li><p>抽象类中可以存在普通方法。</p></li><li><p>抽象类的子类要么重写抽象类中的所有抽象方法，要么是抽象类。</p></li></ul></div><p>abstract 关键字的冲突：</p><ul><li><p>final：被 abstract 修饰的方法，强制要求子类重写，被 final 修饰的方法子类不能重写。</p></li><li><p>private：被 abstract 修饰的方法，强制要求子类重写，被 private 修饰的方法子类不能重写。</p></li><li><p>static：被 static 修饰的方法可以类名调用，类名调用抽象方法没有意义。</p></li></ul><h2 id="interface" tabindex="-1"><a class="header-anchor" href="#interface" aria-hidden="true">#</a> interface</h2><p>定义接口的关键字 <code>public interface 接口名 {} </code>。</p><ul><li><p>接口不能实例化。</p></li><li><p>接口和类之间是实现关系，通过implements关键字表示 <code>public class 类名 implements 接口名 {}</code>。</p></li><li><p>接口的子类（实现类）要么重写接口中的所有抽象方法，要么是抽象类。</p></li></ul><p>接口中的成员特点：</p><ul><li><p>成员变量，只能是常量，默认修饰符：<code>public static final</code></p></li><li><p>没有构造方法。</p></li><li><p>成员方法只能是抽象方法，默认修饰符：<code>public abstract</code></p></li><li><p>关于接口中的方法，DK8 和 JDK9 中有一些新特性。</p></li></ul><h2 id="instanceof" tabindex="-1"><a class="header-anchor" href="#instanceof" aria-hidden="true">#</a> instanceof</h2><p>使用格式：<code>对象名 instanceof 类型</code></p><p>通俗的理解：判断关键字左边的对象是否是右边的类型，返回 boolean 类型结果。</p><h2 id="eum" tabindex="-1"><a class="header-anchor" href="#eum" aria-hidden="true">#</a> eum</h2><p>枚举关键字，枚举是一种特殊的类，它的格式是：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> 枚举类名<span class="token punctuation">{</span>
    枚举项<span class="token number">1</span><span class="token punctuation">,</span>枚举项<span class="token number">2</span><span class="token punctuation">,</span>枚举项<span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,41),l=[e];function p(c,o){return a(),s("div",null,l)}const r=n(i,[["render",p],["__file","Javaguanjianzi.html.vue"]]);export{r as default};
