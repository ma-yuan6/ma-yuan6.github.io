import{_ as n,o as e,c as a,e as s}from"./app-9e62998e.js";const t="/assets/变量的内存-6c4f942e.png",o={},p=s(`<p>我们都知道计算机资源主要存储在两个地方。一个是 <em>硬盘</em>，一个是 <em>内存</em> 。在编写程序定义变量的过程，我们就会申请内存空间，使用完后就应该释放。否则可能会造成 <em>内存溢出</em> 。好在 Python 存在 <em><strong>垃圾回收机制</strong></em> 不用我们进行内存管理。</p><p>垃圾回收机制主要包括：</p><ul><li>引用计数</li><li>标记清除</li><li>分代回收</li></ul><h2 id="引用计数" tabindex="-1"><a class="header-anchor" href="#引用计数" aria-hidden="true">#</a> 引用计数</h2><p>引用计数就是一个值被几个变量引用。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>name <span class="token operator">=</span> <span class="token string">&#39;ma&#39;</span> <span class="token comment"># 18被age引用</span>
nam2 <span class="token operator">=</span> name <span class="token comment"># 18 被age、age2同时引用 </span>
<span class="token comment"># 此时 &#39;ma&#39; 的引用计数为2。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>假如我们再执行<code>del name</code> 删除变量 name，<code>name = &#39;a&#39;</code>改变name2的指向。那么<code>ma</code>引用计数变为 0。就会被内存回收。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p><code>del name</code> 不是删除 <code>&#39;ma&#39;</code>，而是删除<code>name</code>和<code>&#39;ma&#39;</code>之间的绑定关系。</p></div><h2 id="标记清除" tabindex="-1"><a class="header-anchor" href="#标记清除" aria-hidden="true">#</a> 标记清除</h2><p>首先我们要明白为什么需要标记清除机制。现在假设我们写了以下代码：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code>l1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> l2<span class="token punctuation">]</span>
l2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span> l1<span class="token punctuation">]</span>
<span class="token keyword">del</span> l1
<span class="token keyword">del</span> l2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们执行两个 <code>del</code> 语句后。外部变量对两个列表的引用为 0 。但两个列表还在相互引用，引用计数不为 0 。这时候我们就无法访问到这两个列表，也没有办法将它从内存中清除，它们会一直占据着内存。这就是 <em><strong>内存泄漏</strong></em> 。</p><p>要想弄明白，标记清除的实现原理。我们需要了解 <strong>变量名</strong> 和 <strong>变量值</strong> 在内存中的存储关系。</p><p><img src="`+t+'" alt="变量的内存"></p><p>如图所示在内存中，变量名存储在 <em><strong>栈区</strong></em> 变量值存储在 <em><strong>堆区</strong></em> 。两者存在引用关系。所谓的标记清除就是 Python 扫描栈区，发现有通过栈区引用不到的值就会将它回收。</p><p>所以上面例子中，即使两个列表还在相互引用，引用计数不为 0 。但是在栈区内没有变量引用这两个列表，那么他们就会被回收。</p><h2 id="分代回收" tabindex="-1"><a class="header-anchor" href="#分代回收" aria-hidden="true">#</a> 分代回收</h2><p>通过 <em>引用计数</em> 和 <em>标记清除</em> 已经可以回收所有垃圾。但是由于每次查看引用计数的时候会遍历扫描所有变量，效率比较低。所以就产生了 <em>分代回收</em> 。举个例子：</p><p>刚开学时，老师每个人都不认识。检查作业时一致同仁，每个人都三天检查一次。但随着时间的增长，对于表现好的同学可能一周检查一次，表现不好的一天检查一次。又过了一段时间，可能表现更好的同学一个月检查一次，表现更不好的再增加检查频率。<em><strong>分代回收机制</strong></em> 也是如此，对不同的变量进行不同频率的扫描，以此来增加扫描效率。</p><p>至此，垃圾回收机制就讲完了。总结来说，垃圾回收机制通过 <em>引用计数</em> 来扫描回收垃圾，通过 <em>标记清除</em> 来回收引用计数回收不了的垃圾，通过 <em>分代回收</em> 来提高效率。</p>',20),c=[p];function i(l,d){return e(),a("div",null,c)}const m=n(o,[["render",i],["__file","lajihuishoujizhi.html.vue"]]);export{m as default};
